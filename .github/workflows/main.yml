# Copyright (c) 2025 AVI-SPL Inc.
# All Rights Reserved.
#
# This workflow performs following:
# Parses the "symphony-devops/commproxies/skip_list" and creates GH outputs for device, account, and environment to be used by release_commproxies job.
# release_commproxies job will use device, account, and environment to make API call to upgrade respective CPX.
#
# Prerequisites:
# - AVISPL/symphony-devops/commproxies/skip_list must be readable and setup correctly in the format specified on top of the file.
#
name: upgrade_multiple_commproxies

on:
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment"
        type: choice
        required: true
        options:
          - PROD
          - EMEA
          - PWC
          - INT
          - DEVOPS
          - DEV
          - QA
          - SIM
        default: ""
      minimum_version:
        description: "Minimum version"
        type: string
        required: true
        default: "6.0.0.0"
      target_tag:
        description: "Target tag/version"
        type: string
        required: true
        default: "Auto-select based on Environment"
      sleep_seconds:
        description: "Pause between upgrade commands (seconds)"
        type: string
        required: true
        default: "0"
      dry_run:
        description: "Check to not send upgrades; only show what would be upgraded."
        type: boolean
        required: true
        default: false

jobs:
  generate_and_upgrade:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout AVISPL/symphony-devops
        uses: actions/checkout@v4.1.1
        with:
          repository: AVISPL/symphony-devops
          ref: develop
          path: ./symphony-devops
          token: ${{ secrets.AVI_SYMPHONY_DEV_CI_TOKEN }}

      - name: Generate list and (optionally) send upgrades
        shell: bash
        env:
          # Symphony / Cloud API Basic Auth
          CPX_USER: ${{ secrets.CPX_UPGRADE_USER }}
          CPX_PASS: ${{ secrets.CPX_UPGRADE_PASSWORD }}

          # Harbor Basic Auth
          HUSER: ${{ secrets.HARBOR_USER }}
          HPASS: ${{ secrets.HARBOR_PASS }}

          INPUT_ENV: ${{ inputs.environment }}
          MIN_VER: ${{ inputs.minimum_version }}
          INPUT_TAG: ${{ inputs.target_tag }}
          SLEEP: ${{ inputs.sleep_seconds }}
          DRY_RUN: ${{ inputs.dry_run }}
        run: |
          set -euo pipefail

          echo "=== Inputs ==="
          echo "Environment:      $INPUT_ENV"
          echo "Minimum version:  $MIN_VER"
          echo "Target tag input: ${INPUT_TAG:-<blank>}"
          echo "Sleep seconds:    $SLEEP"
          echo "Dry-run:          $DRY_RUN"
          echo

          # ------------------------------------------------------------
          # Environment mapping:
          # - API suffix uses leading dash (except PROD is empty)
          # - API domain differs by env family:
          #   PROD/EMEA/PWC/INT => apisymphony.com
          #   others            => vnocsymphony.com
          # - Cloud suffix is derived from API suffix by stripping leading '-'
          # ------------------------------------------------------------
          case "$INPUT_ENV" in
            PROD)   API_SUFFIX="";       API_DOMAIN="apisymphony.com" ;;
            EMEA)   API_SUFFIX="-emea";  API_DOMAIN="apisymphony.com" ;;
            PWC)    API_SUFFIX="-pwc";   API_DOMAIN="apisymphony.com" ;;
            INT)    API_SUFFIX="-int";   API_DOMAIN="apisymphony.com" ;;
            DEVOPS) API_SUFFIX="-devops"; API_DOMAIN="vnocsymphony.com" ;;
            DEV)    API_SUFFIX="-dev";    API_DOMAIN="vnocsymphony.com" ;;
            QA)     API_SUFFIX="-qa";     API_DOMAIN="vnocsymphony.com" ;;
            SIM)    API_SUFFIX="-sim";    API_DOMAIN="vnocsymphony.com" ;;
            *) echo "Unknown environment: $INPUT_ENV"; exit 1;;
          esac

          # Cloud suffix: PROD => "", others => remove leading dash
          CLOUD_SUFFIX="${API_SUFFIX#-}"

          echo "API host base: api-symphony${API_SUFFIX}.${API_DOMAIN}"
          echo "Cloud host base: cloud${CLOUD_SUFFIX}.avisplsymphony.com (PROD uses cloud.avisplsymphony.com)"
          echo

          # -----------------------------
          # Default tag selection
          # -----------------------------
          TT="Auto-select based on Environment"

          if [[ "${INPUT_TAG,,}" == "${TT}" ]]; then
            case "$INPUT_ENV" in
              PROD|EMEA|PWC) TAG="latest";;
              INT|DEVOPS)    TAG="staging";;
              DEV|QA|SIM)    TAG="snapshot";;
              *)             TAG="latest";;
            esac
          else
            TAG="$INPUT_TAG"
          fi
          echo "Using target tag: $TAG"
          echo

          # -----------------------------
          # Resolve TAG -> numeric version via Harbor
          # -----------------------------
          echo "=== Resolving numeric version from Harbor ==="
          # Get digest if requested tag
          digest="$(curl -s -u "$HUSER:$HPASS" \
            "https://registry.vnocsymphony.com/api/v2.0/projects/commproxy/repositories/cpx_tomcat/artifacts/$TAG" \
            | jq -r '.digest')"

          if [[ -z "$digest" || "$digest" == "null" ]]; then
            echo "ERROR: Failed to resolve digest for tag '$TAG'"
            exit 1
          fi

          # get all tags associated with that digest
          readarray -t tags < <(
            curl -s -u "$HUSER:$HPASS" \
              "https://registry.vnocsymphony.com/api/v2.0/projects/commproxy/repositories/cpx_tomcat/artifacts/$digest" \
              | jq -r '.tags[].name'
          )

          # extract the tag that only has numbers and periods
          TARGET_VER=""
          for t in "${tags[@]}"; do
            if [[ "$t" =~ ^[0-9]+(\.[0-9]+)*$ ]]; then
              TARGET_VER="$t"
              break
            fi
          done

          if [[ -z "$TARGET_VER" ]]; then
            echo "ERROR: No numeric version tag found associated with '$TAG' (digest $digest)"
            exit 1
          fi

          echo "Resolved target version: $TARGET_VER"
          echo

          # -----------------------------
          # Version compare helpers (sort -V)
          # min <= ver < target
          # -----------------------------
          ver_lt () { [[ "$(printf '%s\n' "$1" "$2" | sort -V | head -n1)" != "$2" ]]; }
          ver_le () { [[ "$1" == "$2" ]] || ver_lt "$1" "$2"; }

          # -----------------------------
          # Load skip list (account names)
          # -----------------------------
          echo "=== Loading skip list ==="
          SKIP_FILE="./symphony-devops/commproxies/skip_list"

          if [[ ! -f "$SKIP_FILE" ]]; then
            echo "ERROR: Required skip list not found at:"
            echo "  $SKIP_FILE"
            echo
            echo "Aborting to prevent unintended upgrades."
            exit 1
          fi

          declare -A SKIP_NAMES
          while IFS= read -r line; do
            line="$(echo "$line" | xargs)"
            [[ -z "$line" || "$line" =~ ^# ]] && continue
            SKIP_NAMES["$line"]=1
          done < "$SKIP_FILE"

          echo "Skip list loaded successfully."
          echo

          # -----------------------------
          # Symphony API auth + CSRF/session
          # -----------------------------
          echo "=== Authenticating to Symphony API ==="
          AUTH_B64="$(printf '%s' "$CPX_USER:$CPX_PASS" | base64 -w0)"
          AUTH="Basic $AUTH_B64"

          API_BASE="https://api-symphony${API_SUFFIX}.${API_DOMAIN}/symphony-api"

          # Prime cookies
          curl -s -c cookies.txt \
            "${API_BASE}/public/version" >/dev/null

          # Use an env-specific device ID for CSRF acquisition (update as needed)
          case "$API_SUFFIX" in
            "")      ENV_DEVICE_ID="6cd67406-4246-459e-9101-42e1b1a256b3";;
            "-emea")  ENV_DEVICE_ID="bbbba169-e56b-4c6f-b283-678b658f1e88";;
            "-int")   ENV_DEVICE_ID="5c22a03f-5286-4bc9-b5ba-09ef327bd9a1";;
            "-pwc")   ENV_DEVICE_ID="6cd67406-4246-459e-9101-42e1b1a256b3";; # set the correct PWC env device id if different
            *)        ENV_DEVICE_ID="6cd67406-4246-459e-9101-42e1b1a256b3";;
          esac

          csrf="$(curl -s -b cookies.txt -c cookies.txt -D - \
              -H "Authorization: $AUTH" \
              "${API_BASE}/monitoring/device/${ENV_DEVICE_ID}" \
            | awk -F': ' 'tolower($1)=="x-csrf-token"{print $2}' | tr -d '\r')"

          if [[ -z "$csrf" ]]; then
            echo "ERROR: Failed to obtain X-CSRF-TOKEN"
            exit 1
          fi
          echo "CSRF token acquired."
          echo

          # -----------------------------
          # Fetch CommProxy devices
          # -----------------------------
          echo "=== Fetching Symphony CommProxy devices ==="
          resp="$(curl -s -b cookies.txt \
            -H "Authorization: $AUTH" \
            -H "X-CSRF-TOKEN: $csrf" \
            -H "Content-Type: application/json" \
            -X POST \
            "${API_BASE}/monitoring/device" \
            -d '{"model":["Symphony CommProxy"]}'
          )"

          total="$(jq '.list | length' <<<"$resp")"
          if [[ "$total" -eq 0 ]]; then
            echo "WARN: No devices returned by the API."
            exit 0
          fi
          echo "Total devices found: $total"
          echo

          # -----------------------------
          # Build final candidate list
          # uuid \t accountId \t accountName \t currentVersion
          # -----------------------------
          candidates_tsv="$RUNNER_TEMP/candidates.tsv"
          : > "$candidates_tsv"

          echo "=== Evaluating devices (api SUCCESS, min <= ver < target, not in skip list) ==="

          jq -c '.list[]' <<<"$resp" | while read -r d; do
            uuid="$(jq -r '.id // ""' <<<"$d" | xargs)"
            ver="$(jq -r '.softwareVersion // "0.0.0.0"' <<<"$d" | xargs)"
            api="$(jq -r '.apiStatusIcon // ""' <<<"$d" | xargs)"

            acct_name="$(jq -r '.room.location.account.name // ""' <<<"$d" | xargs)"

            acct_id="$(
              jq -r '
                .room.location.account.id //
                .room.location.account.accountId //
                .accountId //
                ""' <<<"$d" | xargs
            )"

            echo "- ${acct_name:-<no-name>} | uuid=$uuid | ver=$ver | api=$api | accountId=${acct_id:-<missing>}"

            [[ -z "$uuid" ]] && exit 0
            [[ "$api" != "SUCCESS" ]] && exit 0

            if ! ver_le "$MIN_VER" "$ver"; then exit 0; fi
            if ! ver_lt "$ver" "$TARGET_VER"; then exit 0; fi

            if [[ -n "$acct_name" && -n "${SKIP_NAMES[$acct_name]+x}" ]]; then
              echo "  -> SKIP (skip list): $acct_name"
              exit 0
            fi

            printf "%s\t%s\t%s\t%s\n" "$uuid" "$acct_id" "$acct_name" "$ver" >> "$candidates_tsv"
          done

          count="$(wc -l < "$candidates_tsv" | tr -d ' ')"
          echo
          echo "=== Summary ==="
          echo "Selected candidates: $count"
          echo

          if [[ "$count" -eq 0 ]]; then
            echo "No upgrade candidates found. Exiting."
            exit 0
          fi

          missing="$(awk -F'\t' '($2==""){print $0}' "$candidates_tsv" | wc -l | tr -d ' ')"
          if [[ "$missing" -gt 0 ]]; then
            echo "ERROR: One or more selected devices are missing accountId, which is required for the cloud control URL."
            echo "Offending rows (uuid<TAB>accountId<TAB>name<TAB>ver):"
            awk -F'\t' '($2==""){print "  " $0}' "$candidates_tsv"
            exit 1
          fi

          if [[ "$DRY_RUN" == "true" ]]; then
            echo "DRY-RUN enabled. Would send upgrades to:"
            awk -F'\t' '{printf " - %s | %s | accountId=%s | ver=%s\n",$3,$1,$2,$4}' "$candidates_tsv"
            exit 0
          fi

          echo "=== Sending upgrade commands (sleep ${SLEEP}s between each) ==="
          while IFS=$'\t' read -r uuid acct_id acct_name ver; do
            label="${acct_name:-<no-name>} | $uuid | ver=$ver | accountId=$acct_id"

            # PROD: CLOUD_SUFFIX="" => cloud.avisplsymphony.com
            # Others: cloud<suffix>.avisplsymphony.com (no dash)
            url="https://cloud${CLOUD_SUFFIX}.avisplsymphony.com/symphony-cloud-api/device/${uuid}/control?accountId=${acct_id}&monitoringSource=CommProxy"

            http_code="$(curl -s -o /dev/null -w '%{http_code}' \
              -u "$CPX_USER:$CPX_PASS" \
              -H "Content-Type: application/json" \
              -X POST \
              "$url" \
              -d '{"Upgrade":"1"}'
            )"

            if [[ "$http_code" =~ ^2 ]]; then
              echo "[SUCCESS] Upgrade sent: $label"
            else
              echo "[ERROR] Upgrade failed (HTTP $http_code): $label"
            fi

            sleep "$SLEEP"
          done < "$candidates_tsv"

          echo
          echo "Done. Check the Symphony portal for status updates."

